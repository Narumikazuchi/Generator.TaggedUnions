namespace Tests.CodeGenerator;

#pragma warning disable IDE1006 // No need to add postfix 'Asynchronously' here
[TestClass]
public class UnmanagedTypes
{
    [TestMethod]
    public async Task UnionOf2Types()
    {
        String source = @"using Narumikazuchi.Generated;
using Narumikazuchi.Generators.TaggedUnions;
using System;

[assembly: UnionOf(typeof(Point), typeof(Vector2D), Typename = ""PlaneEntity"")]

public struct Point
{
    public Int32 X { get; set; }

    public Int32 Y { get; set; }
}

public struct Vector2D
{
    public Int32 X { get; set; }

    public Int32 Y { get; set; }
}";

        String generated = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Narumikazuchi.Generated
{
    /// <summary>
    /// A type that can be assigned either of these types: <code><see cref=""Point""/> | <see cref=""Vector2D""/></code>
    /// </summary>
    [CompilerGenerated]
    public readonly struct PlaneEntity
    {
        static public implicit operator PlaneEntity(Point value)
        {
            return new PlaneEntity(value);
        }

        static public PlaneEntity operator |(PlaneEntity first, Point second)
        {
            if (first.m_Tag == Tag.Uninitialized)
            {
                return new PlaneEntity(second);
            }
            else
            {
                return first;
            }
        }

        static public implicit operator PlaneEntity(Vector2D value)
        {
            return new PlaneEntity(value);
        }

        static public PlaneEntity operator |(PlaneEntity first, Vector2D second)
        {
            if (first.m_Tag == Tag.Uninitialized)
            {
                return new PlaneEntity(second);
            }
            else
            {
                return first;
            }
        }

        public override bool Equals(object? obj)
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.Equals(obj);
                case Tag.Tag_2:
                    return m_2.Equals(obj);
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public override int GetHashCode()
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.GetHashCode();
                case Tag.Tag_2:
                    return m_2.GetHashCode();
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public override string ToString()
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.ToString();
                case Tag.Tag_2:
                    return m_2.ToString();
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public bool Is([NotNullWhen(true)] out Point? result)
        {
            if (m_Tag == Tag.Tag_1)
            {
                result = m_1;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }

        public bool Is([NotNullWhen(true)] out Vector2D? result)
        {
            if (m_Tag == Tag.Tag_2)
            {
                result = m_2;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }

        public int X
        {
            get
            {
                switch (m_Tag)
                {
                case Tag.Tag_1:
                   return m_1.X;
                case Tag.Tag_2:
                   return m_2.X;
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
                }
            }
        }

        public int Y
        {
            get
            {
                switch (m_Tag)
                {
                case Tag.Tag_1:
                   return m_1.Y;
                case Tag.Tag_2:
                   return m_2.Y;
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
                }
            }
        }

        public bool HasValue
        {
            get
            {
                return m_Tag != Tag.Uninitialized;
            }
        }

        private PlaneEntity(Point value) : this()
        {
            m_1 = value;
            m_Tag = Tag.Tag_1;
        }

        private PlaneEntity(Vector2D value) : this()
        {
            m_2 = value;
            m_Tag = Tag.Tag_2;
        }

        private enum Tag
        {
            Uninitialized,
            Tag_1,
            Tag_2,
        }

        private readonly Point m_1;
        private readonly Vector2D m_2;
        private readonly Tag m_Tag;
    }
}";

        await GeneratorTest.VerifySourceGeneratorAsynchronously(source, ("Narumikazuchi.Generators.TaggedUnions.Core\\Narumikazuchi.Generators.TaggedUnions.Generators.TaggedUnionGenerator\\PlaneEntity.g.cs", SourceText.From(generated, Encoding.UTF8)));
    }

    [TestMethod]
    public async Task UnionOfManyTypes()
    {
        String source = @"using Narumikazuchi.Generated;
using Narumikazuchi.Generators.TaggedUnions;
using System;

[assembly: UnionOf(typeof(Point), typeof(Vector2D), typeof(Vector3D), Typename = ""SpaceEntity"")]

public struct Point
{
    public Int32 X { get; set; }

    public Int32 Y { get; set; }
}

public struct Vector2D
{
    public Int32 X { get; set; }

    public Int32 Y { get; set; }
}

public struct Vector3D
{
    public Int32 X { get; set; }

    public Int32 Y { get; set; }

    public Int32 Z { get; set; }
}";

        String generated = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Narumikazuchi.Generated
{
    /// <summary>
    /// A type that can be assigned either of these types: <code><see cref=""Point""/> | <see cref=""Vector2D""/> | <see cref=""Vector3D""/></code>
    /// </summary>
    [CompilerGenerated]
    public readonly struct SpaceEntity
    {
        static public implicit operator SpaceEntity(Point value)
        {
            return new SpaceEntity(value);
        }

        static public SpaceEntity operator |(SpaceEntity first, Point second)
        {
            if (first.m_Tag == Tag.Uninitialized)
            {
                return new SpaceEntity(second);
            }
            else
            {
                return first;
            }
        }

        static public implicit operator SpaceEntity(Vector2D value)
        {
            return new SpaceEntity(value);
        }

        static public SpaceEntity operator |(SpaceEntity first, Vector2D second)
        {
            if (first.m_Tag == Tag.Uninitialized)
            {
                return new SpaceEntity(second);
            }
            else
            {
                return first;
            }
        }

        static public implicit operator SpaceEntity(Vector3D value)
        {
            return new SpaceEntity(value);
        }

        static public SpaceEntity operator |(SpaceEntity first, Vector3D second)
        {
            if (first.m_Tag == Tag.Uninitialized)
            {
                return new SpaceEntity(second);
            }
            else
            {
                return first;
            }
        }

        public override bool Equals(object? obj)
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.Equals(obj);
                case Tag.Tag_2:
                    return m_2.Equals(obj);
                case Tag.Tag_3:
                    return m_3.Equals(obj);
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public override int GetHashCode()
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.GetHashCode();
                case Tag.Tag_2:
                    return m_2.GetHashCode();
                case Tag.Tag_3:
                    return m_3.GetHashCode();
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public override string ToString()
        {
            switch (m_Tag)
            {
                case Tag.Tag_1:
                    return m_1.ToString();
                case Tag.Tag_2:
                    return m_2.ToString();
                case Tag.Tag_3:
                    return m_3.ToString();
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
            };
        }

        public bool Is([NotNullWhen(true)] out Point? result)
        {
            if (m_Tag == Tag.Tag_1)
            {
                result = m_1;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }

        public bool Is([NotNullWhen(true)] out Vector2D? result)
        {
            if (m_Tag == Tag.Tag_2)
            {
                result = m_2;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }

        public bool Is([NotNullWhen(true)] out Vector3D? result)
        {
            if (m_Tag == Tag.Tag_3)
            {
                result = m_3;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }

        public int X
        {
            get
            {
                switch (m_Tag)
                {
                case Tag.Tag_1:
                   return m_1.X;
                case Tag.Tag_2:
                   return m_2.X;
                case Tag.Tag_3:
                   return m_3.X;
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
                }
            }
        }

        public int Y
        {
            get
            {
                switch (m_Tag)
                {
                case Tag.Tag_1:
                   return m_1.Y;
                case Tag.Tag_2:
                   return m_2.Y;
                case Tag.Tag_3:
                   return m_3.Y;
                default:
                    throw new Narumikazuchi.Generators.TaggedUnions.NotInitialized();
                }
            }
        }

        public bool HasValue
        {
            get
            {
                return m_Tag != Tag.Uninitialized;
            }
        }

        private SpaceEntity(Point value) : this()
        {
            m_1 = value;
            m_Tag = Tag.Tag_1;
        }

        private SpaceEntity(Vector2D value) : this()
        {
            m_2 = value;
            m_Tag = Tag.Tag_2;
        }

        private SpaceEntity(Vector3D value) : this()
        {
            m_3 = value;
            m_Tag = Tag.Tag_3;
        }

        private enum Tag
        {
            Uninitialized,
            Tag_1,
            Tag_2,
            Tag_3,
        }

        private readonly Point m_1;
        private readonly Vector2D m_2;
        private readonly Vector3D m_3;
        private readonly Tag m_Tag;
    }
}";

        await GeneratorTest.VerifySourceGeneratorAsynchronously(source, ("Narumikazuchi.Generators.TaggedUnions.Core\\Narumikazuchi.Generators.TaggedUnions.Generators.TaggedUnionGenerator\\SpaceEntity.g.cs", SourceText.From(generated, Encoding.UTF8)));
    }
}